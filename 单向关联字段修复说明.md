# 单向关联字段修复说明 🔧

## 🔄 字段类型变更

你将飞书多维表格中 **菜品表** 的 `category_id` 字段从 **文本类型** 改为了 **单向关联类型**。

### 变更前后对比

| 项目 | 变更前 | 变更后 |
|------|--------|--------|
| 字段类型 | 文本 | 单向关联 |
| 存储内容 | 分类名称（如"热菜"） | 分类记录 ID |
| API 返回格式 | `"category_id": "热菜"` | `"category_id": {"link_record_ids": ["recv2fdHzkkUMH"]}` |

---

## 🐛 遇到的问题

### 问题 1: 数据解析错误

**原因：** `parseFieldValue` 函数无法识别单向关联字段的数据格式。

**飞书单向关联字段返回格式：**
```json
{
  "category_id": {
    "link_record_ids": ["recv2fdHzkkUMH"]
  }
}
```

**原代码逻辑：**
```javascript
// 只能处理文本和数组格式，无法处理 link_record_ids 格式
function parseFieldValue(value) {
  if (!value) return null

  if (Array.isArray(value) && value.length > 0) {
    if (value[0].text !== undefined) {
      return value[0].text
    }
    return value[0]
  }

  if (typeof value === 'object' && value.text !== undefined) {
    return value.text
  }

  return value
}
```

### 问题 2: 分类筛选失败

**原因：** `getDishes` 函数使用分类名称进行筛选，但现在需要使用分类记录 ID。

**原代码逻辑：**
```javascript
// 错误：尝试用分类名称匹配记录 ID
if (categoryName) {
  conditions.push({
    field_name: 'category_id',
    operator: 'is',
    value: [categoryName]  // ❌ 这是名称，但字段存的是 ID
  })
}
```

---

## ✅ 修复方案

### 修复 1: 更新 `parseFieldValue` 函数

添加了对单向关联/双向关联字段的支持：

```javascript
function parseFieldValue(value) {
  if (!value) return null

  // ✅ 新增：单向关联/双向关联字段
  if (typeof value === 'object' && value.link_record_ids) {
    return value.link_record_ids  // 返回 ID 数组
  }

  // 原有的文本数组格式
  if (Array.isArray(value) && value.length > 0) {
    if (value[0].text !== undefined) {
      return value[0].text
    }
    return value[0]
  }

  // 原有的文本对象格式
  if (typeof value === 'object' && value.text !== undefined) {
    return value.text
  }

  return value
}
```

### 修复 2: 更新 `getDishes` 函数

添加了两步查询逻辑：
1. 先通过分类名称查找分类记录 ID
2. 再使用记录 ID 筛选菜品

```javascript
export async function getDishes(categoryName) {
  try {
    // ✅ 步骤 1: 如果指定了分类名称，先查找分类 ID
    let categoryRecordId = null
    if (categoryName) {
      const categoryResponse = await searchRecords(TABLES.CATEGORIES, {
        filter: {
          conjunction: 'and',
          conditions: [
            {
              field_name: 'name',
              operator: 'is',
              value: [categoryName]
            }
          ]
        }
      })

      if (categoryResponse.code === 0 && categoryResponse.data?.items?.length > 0) {
        categoryRecordId = categoryResponse.data.items[0].record_id
      }
    }

    const conditions = [
      {
        field_name: 'status',
        operator: 'is',
        value: ['上架']
      }
    ]

    // ✅ 步骤 2: 使用记录 ID 筛选，使用 contains 操作符
    if (categoryRecordId) {
      conditions.push({
        field_name: 'category_id',
        operator: 'contains',  // 关联字段使用 contains
        value: [categoryRecordId]
      })
    }

    // ... 其余代码
  }
}
```

**为什么使用 `contains` 操作符？**
- 单向关联字段是数组类型：`["recXXX"]`
- `is` 操作符要求完全匹配整个数组
- `contains` 操作符检查数组中是否包含指定的 ID

---

## 📊 数据流程对比

### 修复前（文本类型）

```
前端请求 → 传入分类名称 "热菜"
    ↓
查询条件：category_id = "热菜"
    ↓
返回数据：category_id: "热菜"
```

### 修复后（单向关联）

```
前端请求 → 传入分类名称 "热菜"
    ↓
查询分类表 → 找到记录 ID "recv2fdHzkkUMH"
    ↓
查询条件：category_id contains "recv2fdHzkkUMH"
    ↓
返回数据：category_id: ["recv2fdHzkkUMH"]
```

---

## 🎯 修复效果

### ✅ 现在支持的字段类型

| 字段类型 | 示例数据 | 解析结果 |
|---------|---------|---------|
| 文本 | `[{"text":"红烧肉","type":"text"}]` | `"红烧肉"` |
| 数字 | `38` | `38` |
| 单选 | `"上架"` | `"上架"` |
| 多选 | `["选项1", "选项2"]` | `["选项1", "选项2"]` |
| **单向关联** | `{"link_record_ids":["recXXX"]}` | `["recXXX"]` ✅ |
| **双向关联** | `{"link_record_ids":["recYYY"]}` | `["recYYY"]` ✅ |
| URL | `[{"link":"http://...","text":"..."}]` | `"http://..."` |

---

## 🧪 测试验证

### 测试步骤

1. **测试菜品列表加载（全部分类）**
   ```javascript
   getDishes()  // 不传分类名称
   ```
   **预期结果：** 返回所有上架菜品

2. **测试菜品列表加载（指定分类）**
   ```javascript
   getDishes("热菜")
   ```
   **预期结果：**
   - 先查询分类表，找到"热菜"的记录 ID
   - 再查询菜品表，返回该分类下的菜品

3. **测试返回数据格式**
   ```javascript
   {
     id: "recXXX",
     name: "红烧肉",
     description: "色泽红亮,肥而不腻",
     price: 38,
     image_url: "https://...",
     category_id: ["recv2fdHzkkUMH"]  // ✅ 数组格式
   }
   ```

### 实际测试结果

运行测试脚本：
```bash
node scripts/test-feishu-api.js
```

**返回的字段格式：**
```json
{
  "category_id": {
    "link_record_ids": ["recv2fdHzkkUMH"]
  }
}
```

**解析后的格式：**
```json
{
  "category_id": ["recv2fdHzkkUMH"]
}
```

✅ **解析正确！**

---

## 📝 代码变更总结

### 修改的文件

- `src/api/feishu.js`
  - 更新了 `parseFieldValue` 函数（第 47-70 行）
  - 重写了 `getDishes` 函数（第 237-309 行）

### 新增功能

1. ✅ 支持单向关联字段解析
2. ✅ 支持双向关联字段解析
3. ✅ 通过分类名称查找分类 ID
4. ✅ 使用 `contains` 操作符筛选关联字段

### 兼容性

- ✅ 向后兼容：如果改回文本类型，代码仍然可以工作
- ✅ 向前兼容：支持未来可能添加的其他关联字段

---

## 🚀 部署到 Netlify

### 1. 代码已推送

```bash
git add src/api/feishu.js
git commit -m "修复单向关联字段解析,支持 category_id 关联类型"
git push github feature/ordering-system:main
```

### 2. Netlify 自动部署

- Netlify 会检测到 GitHub 更新
- 自动触发重新构建和部署
- 大约 2-3 分钟后生效

### 3. 验证修复

部署完成后：
1. 访问你的 Netlify 网站
2. 登录系统
3. 查看菜单页面
4. 点击不同分类标签
5. 检查是否能正确显示对应分类的菜品

---

## 🔍 可能遇到的问题

### Q1: 菜品列表为空

**可能原因：**
- 分类名称拼写错误
- 分类表中没有对应的分类
- 菜品的 category_id 未关联到分类

**排查方法：**
1. 打开浏览器控制台（F12）
2. 查看 Network 标签
3. 找到 `/records/search` 请求
4. 查看请求参数和响应数据

### Q2: 分类筛选不生效

**可能原因：**
- 菜品的 category_id 字段为空
- category_id 未正确关联到分类记录

**解决方案：**
1. 在飞书多维表格中打开菜品表
2. 检查每个菜品的 category_id 字段
3. 确保都已关联到正确的分类

### Q3: 控制台报错 "contains is not a valid operator"

**可能原因：**
- 飞书 API 版本不支持 contains 操作符

**解决方案：**
改用客户端过滤：
```javascript
// 查询所有上架菜品
const allDishes = await searchRecords(...)

// 在客户端过滤
const filteredDishes = categoryRecordId
  ? allDishes.filter(dish =>
      dish.category_id?.includes(categoryRecordId)
    )
  : allDishes
```

---

## ✅ 检查清单

- [x] 更新了 `parseFieldValue` 函数
- [x] 重写了 `getDishes` 函数
- [x] 构建测试通过
- [x] 代码已提交到 Git
- [x] 代码已推送到 GitHub
- [ ] Netlify 部署完成（等待 2-3 分钟）
- [ ] 前端测试菜单加载
- [ ] 前端测试分类筛选

---

## 🎉 总结

**修复内容：**
- ✅ 支持飞书单向关联字段的数据解析
- ✅ 实现了通过分类名称查找并筛选菜品
- ✅ 使用正确的操作符（`contains`）筛选关联字段

**预期效果：**
- ✅ 菜单页面能正常显示所有菜品
- ✅ 点击分类标签能正确筛选菜品
- ✅ 菜品数据包含正确的分类 ID

**下一步：**
等待 Netlify 部署完成（2-3 分钟），然后刷新网站测试功能是否正常！
