# 订单详情表设计方案 📊

## 🎯 设计目标

将订单和菜品的多对多关系拆分成独立的订单详情表,实现:
- 每个订单可以包含多个菜品
- 每个菜品可以出现在多个订单中
- 方便统计每个菜品的销售情况
- 保存下单时的价格(防止菜品价格变动影响历史订单)

---

## 📋 表结构设计

### 表名: 订单详情表 (Order Details)

| 字段名 | 飞书字段类型 | 说明 | 配置 | 是否必填 |
|--------|------------|------|------|---------|
| 详情ID | 文本(自动生成) | 记录唯一标识 | 系统自动生成 | 是 |
| 订单ID | 单向关联 | 关联到订单表 | 关联表: 订单表<br>显示字段: 订单号 | 是 |
| 菜品ID | 单向关联 | 关联到菜品表 | 关联表: 菜品表<br>显示字段: 菜品名称 | 是 |
| 菜品名称 | 文本 | 冗余存储菜品名称 | 防止菜品改名后查不到 | 是 |
| 单价 | 数字 | 下单时的菜品价格 | 货币格式: ¥<br>小数位: 2 | 是 |
| 数量 | 数字 | 购买数量 | 整数格式 | 是 |
| 小计 | 公式 或 数字 | 单价 × 数量 | 公式: `[单价] * [数量]` | 是 |
| 创建时间 | 创建时间 | 记录创建时间 | 自动填充 | 是 |

---

## 🔗 表关系设计

### 三张表的关系

```
┌─────────────┐
│   订单表     │
│  (Orders)   │
├─────────────┤
│ 订单号      │← PK
│ 用户名      │
│ 总金额      │
│ 总数量      │
│ dishes_detail│ (可选,JSON格式备份)
│ 状态        │
│ 创建时间    │
└─────────────┘
      │
      │ 1
      │
      ├─────────────────┐
      │                 │
      │ N               │
      ↓                 │
┌─────────────┐         │
│ 订单详情表   │         │
│(Order Details)│       │
├─────────────┤         │
│ 详情ID      │← PK     │
│ 订单ID      │─────────┘ FK
│ 菜品ID      │─────────┐ FK
│ 菜品名称    │         │
│ 单价        │         │
│ 数量        │         │
│ 小计        │         │
│ 创建时间    │         │
└─────────────┘         │
                        │
                        │
                        ↓
                  ┌─────────────┐
                  │   菜品表     │
                  │  (Dishes)   │
                  ├─────────────┤
                  │ 菜品ID      │← PK
                  │ 菜品名称    │
                  │ 描述        │
                  │ 价格        │
                  │ 分类ID      │
                  │ 图片URL     │
                  │ 状态        │
                  │ 排序        │
                  └─────────────┘
```

---

## 🛠️ 在飞书多维表格中创建

### 步骤 1: 创建表

1. 打开多维表格: https://hx9pg0opel7.feishu.cn/base/WcmNbFvM5aRWdVsegQZcLa9gnme
2. 点击左下角 "+" 号
3. 选择"创建空白表"
4. 命名为"订单详情表"

### 步骤 2: 添加字段

#### 字段 1: 订单ID (单向关联)

```
字段名称: 订单ID
字段类型: 单向关联
关联表格: 订单表
显示字段: 订单号
允许关联多条: 否
```

**操作步骤:**
1. 点击"添加字段"
2. 选择"单向关联"
3. 选择关联表"订单表"
4. 显示字段选择"订单号"

#### 字段 2: 菜品ID (单向关联)

```
字段名称: 菜品ID
字段类型: 单向关联
关联表格: 菜品表
显示字段: 菜品名称
允许关联多条: 否
```

#### 字段 3: 菜品名称 (文本)

```
字段名称: 菜品名称
字段类型: 文本
说明: 冗余存储,防止菜品改名
```

#### 字段 4: 单价 (数字)

```
字段名称: 单价
字段类型: 数字
数字格式: 货币
货币符号: ¥
小数位数: 2
```

#### 字段 5: 数量 (数字)

```
字段名称: 数量
字段类型: 数字
数字格式: 整数
```

#### 字段 6: 小计 (公式)

```
字段名称: 小计
字段类型: 公式
公式表达式: [单价] * [数量]
数字格式: 货币
货币符号: ¥
小数位数: 2
```

**或者使用数字类型** (由前端计算后写入):
```
字段名称: 小计
字段类型: 数字
数字格式: 货币
货币符号: ¥
小数位数: 2
```

#### 字段 7: 创建时间 (创建时间)

```
字段名称: 创建时间
字段类型: 创建时间
日期格式: yyyy/MM/dd HH:mm
自动填充: 是
```

---

## 💻 代码实现方案

### 方案 1: 保持现有设计 (推荐)

**优点:**
- 实现简单,不需要大改代码
- `dishes_detail` 字段作为快速查询的备份
- 订单详情表用于统计分析

**实现方式:**
- 订单表保留 `dishes_detail` 字段(JSON 格式)
- 创建订单时,同时写入订单详情表
- 查询历史订单时,直接从 `dishes_detail` 读取(快速)
- 统计菜品销量时,查询订单详情表

### 方案 2: 完全使用订单详情表

**优点:**
- 数据结构更规范
- 避免数据冗余

**缺点:**
- 需要修改历史订单查询逻辑
- 需要关联查询,性能可能下降

---

## 📝 环境变量配置

需要在 `.env` 文件中添加订单详情表的 Table ID:

```bash
# 订单详情表
VITE_FEISHU_ORDER_DETAILS_TABLE_ID=你的表ID
```

**如何获取 Table ID:**
1. 在飞书多维表格中打开订单详情表
2. 查看浏览器地址栏
3. 格式: `https://xxx.feishu.cn/base/APP_TOKEN?table=TABLE_ID`
4. 复制 `TABLE_ID` 部分

---

## 🔧 代码实现示例

### 1. 添加配置

**文件:** `src/api/feishu.js`

```javascript
const TABLES = {
  USERS: import.meta.env.VITE_FEISHU_USERS_TABLE_ID,
  ANNOUNCEMENTS: import.meta.env.VITE_FEISHU_ANNOUNCEMENTS_TABLE_ID,
  CATEGORIES: import.meta.env.VITE_FEISHU_CATEGORIES_TABLE_ID,
  DISHES: import.meta.env.VITE_FEISHU_DISHES_TABLE_ID,
  ORDERS: import.meta.env.VITE_FEISHU_ORDERS_TABLE_ID,
  ORDER_DETAILS: import.meta.env.VITE_FEISHU_ORDER_DETAILS_TABLE_ID  // ✅ 新增
}
```

### 2. 创建订单详情记录

```javascript
// 创建订单详情记录
async function createOrderDetails(orderRecordId, dishesDetail) {
  try {
    const promises = dishesDetail.map(item => {
      return createRecord(TABLES.ORDER_DETAILS, {
        订单ID: [orderRecordId],  // 单向关联字段,传入数组
        菜品ID: [item.dishId],     // 需要从购物车传入菜品ID
        菜品名称: item.菜品名称,
        单价: item.单价,
        数量: item.数量,
        小计: item.小计
      })
    })

    await Promise.all(promises)
    return { success: true }
  } catch (error) {
    console.error('创建订单详情失败:', error)
    return { success: false, error }
  }
}
```

### 3. 修改创建订单函数

```javascript
export async function createOrder(orderData) {
  try {
    // 1. 创建订单主记录
    const orderResponse = await createRecord(TABLES.ORDERS, {
      order_no: orderData.order_no,
      username: orderData.username,
      total_amount: orderData.total_amount,
      total_quantity: orderData.total_quantity,
      dishes_detail: JSON.stringify(orderData.dishes_detail),
      status: '待处理'
    })

    if (orderResponse.code !== 0) {
      return {
        success: false,
        message: orderResponse.msg || '创建订单失败'
      }
    }

    // 2. 创建订单详情记录
    const orderRecordId = orderResponse.data.record.record_id
    await createOrderDetails(orderRecordId, orderData.dishes_detail)

    return {
      success: true,
      data: orderResponse.data
    }
  } catch (error) {
    console.error('创建订单失败:', error)
    return {
      success: false,
      message: '创建订单失败,请稍后重试'
    }
  }
}
```

### 4. 修改购物车数据结构

**文件:** `src/views/Cart.vue`

需要在订单数据中包含菜品ID:

```javascript
dishes_detail: cartStore.items.map(item => ({
  dishId: item.id,      // ✅ 新增:菜品记录ID
  菜品名称: item.name,
  单价: item.price,
  数量: item.quantity,
  小计: item.price * item.quantity
}))
```

---

## 📊 使用场景

### 场景 1: 查询某个订单的菜品明细

```javascript
// 通过订单ID查询订单详情
async function getOrderDetails(orderRecordId) {
  const response = await searchRecords(TABLES.ORDER_DETAILS, {
    filter: {
      conjunction: 'and',
      conditions: [
        {
          field_name: '订单ID',
          operator: 'contains',
          value: [orderRecordId]
        }
      ]
    }
  })

  return response.data?.items || []
}
```

### 场景 2: 统计某个菜品的销量

```javascript
// 统计某个菜品的总销量
async function getDishSales(dishRecordId) {
  const response = await searchRecords(TABLES.ORDER_DETAILS, {
    filter: {
      conjunction: 'and',
      conditions: [
        {
          field_name: '菜品ID',
          operator: 'contains',
          value: [dishRecordId]
        }
      ]
    }
  })

  // 统计总数量
  const totalQuantity = response.data?.items.reduce((sum, item) => {
    const parsed = parseRecord(item)
    return sum + (parsed.数量 || 0)
  }, 0)

  return totalQuantity
}
```

### 场景 3: 查询某个时间段内的菜品销售排行

```javascript
// 查询最受欢迎的菜品
async function getPopularDishes(startTime, endTime) {
  const response = await searchRecords(TABLES.ORDER_DETAILS, {
    // 可以通过创建时间筛选
  })

  // 按菜品分组统计
  const dishStats = {}
  response.data?.items.forEach(item => {
    const parsed = parseRecord(item)
    const dishId = parsed.菜品ID?.[0]
    const dishName = parsed.菜品名称
    const quantity = parsed.数量

    if (!dishStats[dishId]) {
      dishStats[dishId] = {
        name: dishName,
        totalQuantity: 0,
        totalAmount: 0
      }
    }

    dishStats[dishId].totalQuantity += quantity
    dishStats[dishId].totalAmount += parsed.小计
  })

  // 排序返回
  return Object.values(dishStats).sort((a, b) =>
    b.totalQuantity - a.totalQuantity
  )
}
```

---

## ✅ 优缺点分析

### 方案对比

| 特性 | 仅用 dishes_detail | 仅用订单详情表 | 两者结合 (推荐) |
|------|-------------------|---------------|----------------|
| 实现难度 | ⭐ 简单 | ⭐⭐⭐ 复杂 | ⭐⭐ 中等 |
| 查询速度 | ⭐⭐⭐ 快 | ⭐⭐ 中等 | ⭐⭐⭐ 快 |
| 统计分析 | ⭐ 困难 | ⭐⭐⭐ 方便 | ⭐⭐⭐ 方便 |
| 数据规范性 | ⭐ 低 | ⭐⭐⭐ 高 | ⭐⭐ 中等 |
| 维护成本 | ⭐⭐ 低 | ⭐⭐⭐ 高 | ⭐⭐ 中等 |

### 推荐方案: 两者结合

**原因:**
1. **历史订单查询** - 使用 `dishes_detail` 字段,快速响应
2. **统计分析** - 使用订单详情表,灵活查询
3. **向后兼容** - 不影响现有功能
4. **逐步迁移** - 可以慢慢将查询逻辑迁移到订单详情表

---

## 🎯 实施步骤

### 阶段 1: 创建表结构 (立即)

1. ✅ 在飞书创建订单详情表
2. ✅ 添加所有必需字段
3. ✅ 配置字段关联关系
4. ✅ 获取 Table ID 并配置到环境变量

### 阶段 2: 修改代码 (可选)

1. 添加订单详情表配置
2. 修改购物车数据结构(包含菜品ID)
3. 修改创建订单函数(同时写入订单详情表)
4. 测试订单创建流程

### 阶段 3: 数据分析 (未来)

1. 开发统计功能(菜品销量排行)
2. 开发销售报表
3. 开发数据可视化图表

---

## 💡 建议

### 当前阶段 (MVP)

**建议先创建表结构,但暂不修改代码:**
- 手动在飞书中创建订单详情表
- 先使用 `dishes_detail` 字段满足基本需求
- 未来需要统计分析时再对接代码

**理由:**
- 现有功能已满足点餐需求
- 避免过度设计
- 快速上线,收集用户反馈

### 未来扩展

当需要以下功能时,再对接订单详情表:
- 📊 菜品销量统计
- 📈 销售趋势分析
- 🏆 热门菜品排行
- 💰 营业额报表
- 👥 用户消费习惯分析

---

## 🔍 FAQ

### Q1: 为什么要冗余存储菜品名称?

**A:** 防止菜品改名后,历史订单查不到原来的名称。例如:
- 订单时菜品名:"红烧肉"
- 后来改名为:"招牌红烧肉"
- 如果不存储名称,历史订单会显示新名称,造成混淆

### Q2: 小计字段用公式还是数字类型?

**A:** 建议使用**数字类型**:
- 公式类型只能在飞书界面显示
- 数字类型可以在代码中计算后写入
- 更灵活,性能更好

### Q3: 订单表还需要保留 dishes_detail 吗?

**A:** 建议**保留**:
- 作为快速查询的备份
- 避免复杂的关联查询
- 历史订单查询性能更好

### Q4: 如何处理菜品价格变动?

**A:** 订单详情表存储下单时的价格:
- 下单时记录当前价格到"单价"字段
- 即使菜品表价格变动,历史订单不受影响
- 保证历史数据的准确性

---

## 📚 参考资料

- [飞书多维表格 - 字段类型](https://open.feishu.cn/document/server-docs/docs/bitable-v1/app-table-field/guide)
- [单向关联字段使用说明](https://open.feishu.cn/document/server-docs/docs/bitable-v1/app-table-field/guide#c8c4f1e6)
- [数据库设计 - 订单表设计最佳实践](https://www.zhihu.com/question/21569316)

---

需要我帮你创建这张表吗?或者你想先自己在飞书中手动创建试试看?
